/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace RewardSystem {
  export type AchievementStruct = {
    id: BigNumberish;
    name: string;
    description: string;
    pointsReward: BigNumberish;
    reputationReward: BigNumberish;
    isActive: boolean;
    requiredSwaps: BigNumberish;
    requiredVolume: BigNumberish;
    requiredChains: BigNumberish;
  };

  export type AchievementStructOutput = [
    id: bigint,
    name: string,
    description: string,
    pointsReward: bigint,
    reputationReward: bigint,
    isActive: boolean,
    requiredSwaps: bigint,
    requiredVolume: bigint,
    requiredChains: bigint
  ] & {
    id: bigint;
    name: string;
    description: string;
    pointsReward: bigint;
    reputationReward: bigint;
    isActive: boolean;
    requiredSwaps: bigint;
    requiredVolume: bigint;
    requiredChains: bigint;
  };

  export type RewardTierStruct = {
    tierId: BigNumberish;
    name: string;
    minPoints: BigNumberish;
    minReputation: BigNumberish;
    bonusMultiplier: BigNumberish;
    isActive: boolean;
  };

  export type RewardTierStructOutput = [
    tierId: bigint,
    name: string,
    minPoints: bigint,
    minReputation: bigint,
    bonusMultiplier: bigint,
    isActive: boolean
  ] & {
    tierId: bigint;
    name: string;
    minPoints: bigint;
    minReputation: bigint;
    bonusMultiplier: bigint;
    isActive: boolean;
  };
}

export interface RewardSystemInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "BASE_POINTS_PER_SWAP"
      | "BASE_REPUTATION_PER_SWAP"
      | "CROSS_CHAIN_BONUS"
      | "LEVEL_UP_THRESHOLD"
      | "VOLUME_BONUS_THRESHOLD"
      | "achievements"
      | "addAchievement"
      | "addRewardTier"
      | "awardBonusPoints"
      | "awardReputation"
      | "awardSwapRewards"
      | "claimRewards"
      | "getAchievement"
      | "getRewardTier"
      | "getUserActivityStat"
      | "getUserRewards"
      | "hasUnlockedAchievement"
      | "owner"
      | "pause"
      | "paused"
      | "renounceOwnership"
      | "rewardTiers"
      | "rewardToken"
      | "transferOwnership"
      | "unlockAchievement"
      | "unpause"
      | "updateRewardToken"
      | "userRewards"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AchievementUnlocked"
      | "LevelUp"
      | "OwnershipTransferred"
      | "Paused"
      | "PointsEarned"
      | "ReputationEarned"
      | "RewardClaimed"
      | "TierUpgraded"
      | "Unpaused"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "BASE_POINTS_PER_SWAP",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BASE_REPUTATION_PER_SWAP",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "CROSS_CHAIN_BONUS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "LEVEL_UP_THRESHOLD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOLUME_BONUS_THRESHOLD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "achievements",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addAchievement",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addRewardTier",
    values: [string, BigNumberish, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "awardBonusPoints",
    values: [AddressLike, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "awardReputation",
    values: [AddressLike, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "awardSwapRewards",
    values: [AddressLike, BigNumberish, boolean, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimRewards",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAchievement",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getRewardTier",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserActivityStat",
    values: [AddressLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserRewards",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "hasUnlockedAchievement",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardTiers",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rewardToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockAchievement",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updateRewardToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "userRewards",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "BASE_POINTS_PER_SWAP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BASE_REPUTATION_PER_SWAP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "CROSS_CHAIN_BONUS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LEVEL_UP_THRESHOLD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOLUME_BONUS_THRESHOLD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "achievements",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addAchievement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addRewardTier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "awardBonusPoints",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "awardReputation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "awardSwapRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAchievement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRewardTier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserActivityStat",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasUnlockedAchievement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardTiers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unlockAchievement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateRewardToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userRewards",
    data: BytesLike
  ): Result;
}

export namespace AchievementUnlockedEvent {
  export type InputTuple = [
    user: AddressLike,
    achievementId: BigNumberish,
    achievementName: string
  ];
  export type OutputTuple = [
    user: string,
    achievementId: bigint,
    achievementName: string
  ];
  export interface OutputObject {
    user: string;
    achievementId: bigint;
    achievementName: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LevelUpEvent {
  export type InputTuple = [user: AddressLike, newLevel: BigNumberish];
  export type OutputTuple = [user: string, newLevel: bigint];
  export interface OutputObject {
    user: string;
    newLevel: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PointsEarnedEvent {
  export type InputTuple = [
    user: AddressLike,
    points: BigNumberish,
    reason: string
  ];
  export type OutputTuple = [user: string, points: bigint, reason: string];
  export interface OutputObject {
    user: string;
    points: bigint;
    reason: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ReputationEarnedEvent {
  export type InputTuple = [
    user: AddressLike,
    reputation: BigNumberish,
    reason: string
  ];
  export type OutputTuple = [user: string, reputation: bigint, reason: string];
  export interface OutputObject {
    user: string;
    reputation: bigint;
    reason: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RewardClaimedEvent {
  export type InputTuple = [user: AddressLike, amount: BigNumberish];
  export type OutputTuple = [user: string, amount: bigint];
  export interface OutputObject {
    user: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TierUpgradedEvent {
  export type InputTuple = [user: AddressLike, newTier: BigNumberish];
  export type OutputTuple = [user: string, newTier: bigint];
  export interface OutputObject {
    user: string;
    newTier: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UnpausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface RewardSystem extends BaseContract {
  connect(runner?: ContractRunner | null): RewardSystem;
  waitForDeployment(): Promise<this>;

  interface: RewardSystemInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  BASE_POINTS_PER_SWAP: TypedContractMethod<[], [bigint], "view">;

  BASE_REPUTATION_PER_SWAP: TypedContractMethod<[], [bigint], "view">;

  CROSS_CHAIN_BONUS: TypedContractMethod<[], [bigint], "view">;

  LEVEL_UP_THRESHOLD: TypedContractMethod<[], [bigint], "view">;

  VOLUME_BONUS_THRESHOLD: TypedContractMethod<[], [bigint], "view">;

  achievements: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        string,
        bigint,
        bigint,
        boolean,
        bigint,
        bigint,
        bigint
      ] & {
        id: bigint;
        name: string;
        description: string;
        pointsReward: bigint;
        reputationReward: bigint;
        isActive: boolean;
        requiredSwaps: bigint;
        requiredVolume: bigint;
        requiredChains: bigint;
      }
    ],
    "view"
  >;

  addAchievement: TypedContractMethod<
    [
      name: string,
      description: string,
      pointsReward: BigNumberish,
      reputationReward: BigNumberish,
      requiredSwaps: BigNumberish,
      requiredVolume: BigNumberish,
      requiredChains: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  addRewardTier: TypedContractMethod<
    [
      name: string,
      minPoints: BigNumberish,
      minReputation: BigNumberish,
      bonusMultiplier: BigNumberish,
      isActive: boolean
    ],
    [void],
    "nonpayable"
  >;

  awardBonusPoints: TypedContractMethod<
    [user: AddressLike, points: BigNumberish, reason: string],
    [void],
    "nonpayable"
  >;

  awardReputation: TypedContractMethod<
    [user: AddressLike, reputation: BigNumberish, reason: string],
    [void],
    "nonpayable"
  >;

  awardSwapRewards: TypedContractMethod<
    [
      user: AddressLike,
      swapAmount: BigNumberish,
      isCrossChain: boolean,
      chainCount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  claimRewards: TypedContractMethod<
    [amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  getAchievement: TypedContractMethod<
    [achievementId: BigNumberish],
    [RewardSystem.AchievementStructOutput],
    "view"
  >;

  getRewardTier: TypedContractMethod<
    [tierId: BigNumberish],
    [RewardSystem.RewardTierStructOutput],
    "view"
  >;

  getUserActivityStat: TypedContractMethod<
    [user: AddressLike, activity: string],
    [bigint],
    "view"
  >;

  getUserRewards: TypedContractMethod<
    [user: AddressLike],
    [
      [bigint, bigint, bigint, bigint, bigint] & {
        totalPoints: bigint;
        totalReputation: bigint;
        level: bigint;
        achievementsUnlocked: bigint;
        lastRewardTime: bigint;
      }
    ],
    "view"
  >;

  hasUnlockedAchievement: TypedContractMethod<
    [user: AddressLike, achievementId: BigNumberish],
    [boolean],
    "view"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  pause: TypedContractMethod<[], [void], "nonpayable">;

  paused: TypedContractMethod<[], [boolean], "view">;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  rewardTiers: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, bigint, bigint, bigint, boolean] & {
        tierId: bigint;
        name: string;
        minPoints: bigint;
        minReputation: bigint;
        bonusMultiplier: bigint;
        isActive: boolean;
      }
    ],
    "view"
  >;

  rewardToken: TypedContractMethod<[], [string], "view">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  unlockAchievement: TypedContractMethod<
    [user: AddressLike, achievementId: BigNumberish],
    [void],
    "nonpayable"
  >;

  unpause: TypedContractMethod<[], [void], "nonpayable">;

  updateRewardToken: TypedContractMethod<
    [newRewardToken: AddressLike],
    [void],
    "nonpayable"
  >;

  userRewards: TypedContractMethod<
    [arg0: AddressLike],
    [
      [bigint, bigint, bigint, bigint, bigint] & {
        totalPoints: bigint;
        totalReputation: bigint;
        level: bigint;
        achievementsUnlocked: bigint;
        lastRewardTime: bigint;
      }
    ],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "BASE_POINTS_PER_SWAP"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "BASE_REPUTATION_PER_SWAP"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "CROSS_CHAIN_BONUS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "LEVEL_UP_THRESHOLD"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "VOLUME_BONUS_THRESHOLD"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "achievements"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        string,
        string,
        bigint,
        bigint,
        boolean,
        bigint,
        bigint,
        bigint
      ] & {
        id: bigint;
        name: string;
        description: string;
        pointsReward: bigint;
        reputationReward: bigint;
        isActive: boolean;
        requiredSwaps: bigint;
        requiredVolume: bigint;
        requiredChains: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "addAchievement"
  ): TypedContractMethod<
    [
      name: string,
      description: string,
      pointsReward: BigNumberish,
      reputationReward: BigNumberish,
      requiredSwaps: BigNumberish,
      requiredVolume: BigNumberish,
      requiredChains: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addRewardTier"
  ): TypedContractMethod<
    [
      name: string,
      minPoints: BigNumberish,
      minReputation: BigNumberish,
      bonusMultiplier: BigNumberish,
      isActive: boolean
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "awardBonusPoints"
  ): TypedContractMethod<
    [user: AddressLike, points: BigNumberish, reason: string],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "awardReputation"
  ): TypedContractMethod<
    [user: AddressLike, reputation: BigNumberish, reason: string],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "awardSwapRewards"
  ): TypedContractMethod<
    [
      user: AddressLike,
      swapAmount: BigNumberish,
      isCrossChain: boolean,
      chainCount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "claimRewards"
  ): TypedContractMethod<[amount: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getAchievement"
  ): TypedContractMethod<
    [achievementId: BigNumberish],
    [RewardSystem.AchievementStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getRewardTier"
  ): TypedContractMethod<
    [tierId: BigNumberish],
    [RewardSystem.RewardTierStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserActivityStat"
  ): TypedContractMethod<
    [user: AddressLike, activity: string],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserRewards"
  ): TypedContractMethod<
    [user: AddressLike],
    [
      [bigint, bigint, bigint, bigint, bigint] & {
        totalPoints: bigint;
        totalReputation: bigint;
        level: bigint;
        achievementsUnlocked: bigint;
        lastRewardTime: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "hasUnlockedAchievement"
  ): TypedContractMethod<
    [user: AddressLike, achievementId: BigNumberish],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "pause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "paused"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "rewardTiers"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, bigint, bigint, bigint, boolean] & {
        tierId: bigint;
        name: string;
        minPoints: bigint;
        minReputation: bigint;
        bonusMultiplier: bigint;
        isActive: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "rewardToken"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "unlockAchievement"
  ): TypedContractMethod<
    [user: AddressLike, achievementId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unpause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateRewardToken"
  ): TypedContractMethod<[newRewardToken: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "userRewards"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [
      [bigint, bigint, bigint, bigint, bigint] & {
        totalPoints: bigint;
        totalReputation: bigint;
        level: bigint;
        achievementsUnlocked: bigint;
        lastRewardTime: bigint;
      }
    ],
    "view"
  >;

  getEvent(
    key: "AchievementUnlocked"
  ): TypedContractEvent<
    AchievementUnlockedEvent.InputTuple,
    AchievementUnlockedEvent.OutputTuple,
    AchievementUnlockedEvent.OutputObject
  >;
  getEvent(
    key: "LevelUp"
  ): TypedContractEvent<
    LevelUpEvent.InputTuple,
    LevelUpEvent.OutputTuple,
    LevelUpEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "Paused"
  ): TypedContractEvent<
    PausedEvent.InputTuple,
    PausedEvent.OutputTuple,
    PausedEvent.OutputObject
  >;
  getEvent(
    key: "PointsEarned"
  ): TypedContractEvent<
    PointsEarnedEvent.InputTuple,
    PointsEarnedEvent.OutputTuple,
    PointsEarnedEvent.OutputObject
  >;
  getEvent(
    key: "ReputationEarned"
  ): TypedContractEvent<
    ReputationEarnedEvent.InputTuple,
    ReputationEarnedEvent.OutputTuple,
    ReputationEarnedEvent.OutputObject
  >;
  getEvent(
    key: "RewardClaimed"
  ): TypedContractEvent<
    RewardClaimedEvent.InputTuple,
    RewardClaimedEvent.OutputTuple,
    RewardClaimedEvent.OutputObject
  >;
  getEvent(
    key: "TierUpgraded"
  ): TypedContractEvent<
    TierUpgradedEvent.InputTuple,
    TierUpgradedEvent.OutputTuple,
    TierUpgradedEvent.OutputObject
  >;
  getEvent(
    key: "Unpaused"
  ): TypedContractEvent<
    UnpausedEvent.InputTuple,
    UnpausedEvent.OutputTuple,
    UnpausedEvent.OutputObject
  >;

  filters: {
    "AchievementUnlocked(address,uint256,string)": TypedContractEvent<
      AchievementUnlockedEvent.InputTuple,
      AchievementUnlockedEvent.OutputTuple,
      AchievementUnlockedEvent.OutputObject
    >;
    AchievementUnlocked: TypedContractEvent<
      AchievementUnlockedEvent.InputTuple,
      AchievementUnlockedEvent.OutputTuple,
      AchievementUnlockedEvent.OutputObject
    >;

    "LevelUp(address,uint256)": TypedContractEvent<
      LevelUpEvent.InputTuple,
      LevelUpEvent.OutputTuple,
      LevelUpEvent.OutputObject
    >;
    LevelUp: TypedContractEvent<
      LevelUpEvent.InputTuple,
      LevelUpEvent.OutputTuple,
      LevelUpEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "Paused(address)": TypedContractEvent<
      PausedEvent.InputTuple,
      PausedEvent.OutputTuple,
      PausedEvent.OutputObject
    >;
    Paused: TypedContractEvent<
      PausedEvent.InputTuple,
      PausedEvent.OutputTuple,
      PausedEvent.OutputObject
    >;

    "PointsEarned(address,uint256,string)": TypedContractEvent<
      PointsEarnedEvent.InputTuple,
      PointsEarnedEvent.OutputTuple,
      PointsEarnedEvent.OutputObject
    >;
    PointsEarned: TypedContractEvent<
      PointsEarnedEvent.InputTuple,
      PointsEarnedEvent.OutputTuple,
      PointsEarnedEvent.OutputObject
    >;

    "ReputationEarned(address,uint256,string)": TypedContractEvent<
      ReputationEarnedEvent.InputTuple,
      ReputationEarnedEvent.OutputTuple,
      ReputationEarnedEvent.OutputObject
    >;
    ReputationEarned: TypedContractEvent<
      ReputationEarnedEvent.InputTuple,
      ReputationEarnedEvent.OutputTuple,
      ReputationEarnedEvent.OutputObject
    >;

    "RewardClaimed(address,uint256)": TypedContractEvent<
      RewardClaimedEvent.InputTuple,
      RewardClaimedEvent.OutputTuple,
      RewardClaimedEvent.OutputObject
    >;
    RewardClaimed: TypedContractEvent<
      RewardClaimedEvent.InputTuple,
      RewardClaimedEvent.OutputTuple,
      RewardClaimedEvent.OutputObject
    >;

    "TierUpgraded(address,uint256)": TypedContractEvent<
      TierUpgradedEvent.InputTuple,
      TierUpgradedEvent.OutputTuple,
      TierUpgradedEvent.OutputObject
    >;
    TierUpgraded: TypedContractEvent<
      TierUpgradedEvent.InputTuple,
      TierUpgradedEvent.OutputTuple,
      TierUpgradedEvent.OutputObject
    >;

    "Unpaused(address)": TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;
    Unpaused: TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;
  };
}
